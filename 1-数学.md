# 数学

## 快速模乘

* |a|,|b|<m，且m在`longlong`范围
* 编译环境支持64个二进制位精度的`long doube`（如x86-64平台的GNU G++）
* 替代方案 `__int128`，不行则改用log复杂度的龟速乘

```cpp
inline LL mul(LL a, LL b, LL m) {
    u64 r = (u64)a * b - (u64)((LD)a / m * b + 0.5L) * m;
    return r < m ? r : r + m;
}
```



## 快速幂

* longlong范围用fpl

```cpp
inline LL fp(LL a, LL b, LL Mod) {
    LL res = (Mod != 1);
    for (; b; b >>= 1, a = a * a % Mod)
        if (b & 1)
            res = res * a % Mod;
    return res;
}

inline LL fpl(LL a, LL b, LL Mod) {
    LL res = (Mod != 1);
    for (; b; b >>= 1, a = mul(a, a, Mod))
        if (b & 1)
            res = mul(res, a, Mod);
    return res;
}
```



## 辗转相除(求最大公约数)

* 实际上`gcd`可以用`<algorithm>`的库函数`__gcd`代替

```cpp
template <typename T>
inline T gcd(T a, T b) {
	while (b){T t = b;b = a % b;a = t;}
	return a;
}

template <typename T>
inline T lcm(T a, T b) { return a / gcd(a, b) * b; }

template<typename T>
inline void exgcd(T a,T b,T&x,T&y,T&d){
	if (b == 0){ x = 1, y = 0, d = a;}
	else{
		exgcd(b, a % b, y, x, d);
		y -= (a / b) * x;
	}
}
```



## 乘法逆元

用欧拉定理(费马小定理)求逆元代码最短

### exgcd求逆元

```cpp
inline int getinv(int a, int p){
    int m = 0, n = 1, x = 1, y = 0, b = p;
    while (b){
        int q = a / b;
        tie(x, m) = make_tuple(m, x - q * m);
        tie(y, n) = make_tuple(n, y - q * n);
        tie(a, b) = make_tuple(b, a - q * b);
    }
    (x < 0) && (x += p);
    return x;
}
```

### 线性递推求逆元

模 $n$ 意义下，设正整数 $i$ 和 $n\%i$ 均存在逆元，则有递推式：

* $$inv(i)=-(n/i)*inv(n\%i)$$

其中  $/$ 和 $\%$ 是C++运算符

一般用于模质数时线性求出 $1..n$ 的逆元



## 线性同余方程组（中国剩余定理）

* 用于合并方程组 $x\equiv a_i(mod\ m_i)$

* 合法运行的数据：
* * {$a$}非负
* * {$m$}为正
* * $2lcm\{m_i\}$在`longlong`范围

* 用`pair<LL,LL>`存 $\{a_i,m_i\}$   前置算法 `快速乘` 和 `辗转相除`

* 有解返回 True，并将第二个方程合并到第一个（得到最小非负解）；否则返回 False

* 注意题目求最小非负解还是正数解！！！

```cpp
inline bool crt(pll &a, pll b){
	LL g, u, d;
	exgcd(a.second, b.second, u, d, g);
	d = b.first - a.first;if (d % g) return 0;
	const LL t = b.second / g;
	a.first += mul(u, d / g, t) * a.second; 
	a.second *= t;
	a.first %= a.second; (a.first < 0) && (a.first += a.second);
	return 1;
}
```



## 大指数运算（欧拉降幂）

$$a^x=\begin{cases}
a^{x\ mod \phi(m)}&(a,m)=1\\
a^x&(a,m)!=1且x< c\\
a^{(x-c)mod\ c+c}&(a,m)!=1且x\geq c\\
\end{cases}$$
其中 $c$ = $m的质因子最高次数 +1$ ，是一个$O(log\ n)$的常数，为计算方便常用$\phi(m)$代替

在快速幂中特殊处理，若$b^c≥\phi(m)$，返回$b^{c\ mod\ \phi(m)+\phi(m)}$，否则返回$b^{c\ mod\ \phi(m)}$

```cpp
inline LL exfp(LL a,LL b,LL Mod){
    /*注意检查Mod<=1e9 且res初值为1*/
    bool f=0;LL res=1;
    for(;b;b>>=1){
        if(a>Mod){f=1;a%=Mod;}
        if(b&1){
            res=res*a;
            if(res>Mod){f=1;res%=Mod;}
        }
        a=a*a;
    }return f?res+Mod:res;
}
```



## 原根

* 只有 $2,4,p^a,2p^a$ 有原根，这里的 $p$ 是奇质数

* (王元)质数 $p$ 的最小正原根是 $O(p^{0.25+\epsilon})$ 的 可暴力check

* 设 $g$ 为 $m$ 的原根，对任意 $x$ 满足 $(x,\phi(m))=1$ ，$g^x$ 也是原根，故原根共有 $\phi(\phi(m))$ 个 

* (原根判定定理) $m$ 的某个既约剩余类 $g$ 为原根 $\iff$ 对 $\phi(m)$ 的任意质约数 $p$ 有 $g^{\frac{\phi(m)}{p}}\neq 1(mod\ m)$

* 用于生成任意(有上限)次单位根，做 NTT（number theoretic transforms） 



## 高次同余方程

* 以下 `p` 均为正整数

### 离散对数（BSGS/exBSGS）

求最小非负整数 $x$ 满足 $a^x\equiv b(mod\ p)$ ， $p\leq 10^9$ 且不必是质数

* 前置算法 `快速幂`   `map/unorded_map`   `__gcd()`  `求逆元`
  * 哈希表 `typedef unordered_map<int,int,neal> HASH;` 

* 视 p 范围换快速乘  由于复杂度 $O(\sqrt(p))$，实际上难以对一般的long long做BSGS ~~多半是想法歪了~~

* 若多组询问 a,p 为常量且始终满足 (b,p)=1  则应复用 h 降低常数 

* 接口  传入非负整数 `a` `b` 和正整数 `p`
  * `log()` 要求 $(a,p)=1$  无解返回-1
  * `operator()` 无特殊要求  无解返回-1

* 求最小正整数需稍作修改  见注释

```cpp
struct{
	int log(int a,int b,int p){
        if((b-1)%p==0)return 0;
        HASH h;const int t=(int)sqrt(p)+1;
		for(int j=0;j<t;++j,b=(LL)b*a%p)h[b]=j;
		int at=(a=fp(a,t,p));
		for(int i=1;i<=t;++i,a=(LL)a*at%p){
            auto it=h.find(a);
            if(it!=h.end())return i*t-(*it).second;
        }return -1;
	}
	int operator()(int a,int b,int p){//(接口)
        if((b-1)%p==0)return 0;//求正整数解则注释掉
        if((b-a)%p==0)return 1;
        a%=p;b%=p;
        const int _a=a,_b=b,_p=p;
		int d=__gcd(a,p),ax=1,t=0;
        while(d>1){
            if(b%d!=0)break;
            b/=d;p/=d;ax=(LL)ax*(a/d)%p;++t;
            d=__gcd(a,p);
        }
        for(int i=2,at=(LL)_a*_a%_p;i<=t;++i,at=(LL)at*_a%_p)if(at==_b)return i;
        if(d>1)return -1;
        int res=log(a,(LL)b*getinv(ax,p)%p,p);//res为-1说明无解 有解则非负
        return res<0?-1:res+t;//求正整数解则要修改
	}
}BSGS;
```



### 模意义下开根（N次剩余）

求 $x$ 满足 $x^a\equiv b(mod\ m)$ 

* 如果： $(b,m)=1$ 且容易计算 $m$ 的原根 $g$ 与 $\phi(m)$
  * 计算离散对数 $y=\log_gb$ （瓶颈所在）
  * 将问题转化为 $x^a=(g^{x'})^a\equiv g^y(mod\ m)$
  * 等价于线性同余方程 $ax'\equiv y(mod\ \phi(m))$ 

~~对于一般的情形，不会~~



### 模奇质数的平方根/立方根

#### 二次剩余的判定

* 设 $n$ 是奇质数 $p$ 的一个既约剩余类

* $n^{\frac{p-1}{2}}mod\ p=\begin{cases}1 \qquad & n是二次剩余 \\ -1 \qquad &  n是非二次剩余 \end{cases}$

#### 平方根（Cipolla算法）

求最小非负整数 $x$ 满足 $x^2\equiv n \left( mod\ p\right)$   $p$ 为不超过 $10^9$ 的质数   $n$ 为非负整数 
* 若有两根则另一根为 $p-x$   若无解返回 -1

* 期望复杂度 $O(log\ p)$   对 $10^{18}$ 以内的 $p$ 需稍作修改  见注释

* 接口 `int ans1 = Square_root(p)(n);`

```CPP
struct Square_root{
	typedef int DAT; //操作数类型
	const DAT P;
	DAT I2;
	Square_root(DAT p = 1) : P(p) {}
	DAT mul(DAT a, DAT b) const{ return (LL)a * b % P;} // DAT=int
	/*DAT mul(DAT a, DAT b) const{
		u64 r = (u64)a * b - (u64)((LD)a / P * b + 0.5L) * P;
		return r < P ? r : r + P;
	}*/ // DAT=long long

	#define X first
	#define Y second
	typedef pair<DAT, DAT> pii;
	pii mul(pii a, pii b) const { return {
		(mul(a.X, b.X) + mul(mul(I2, a.Y), b.Y)) % P, 
		(mul(a.X, b.Y) + mul(a.Y, b.X)) % P};}
	
	template <class T>
	T pow(T a, DAT b, T x){
		for (; b; b /= 2, a = mul(a, a)) if (b & 1)x = mul(x, a);
		return x;
	}

	DAT operator()(DAT n){ 
		if ((n %= P) <= 1) return n;
		if (pow(n, (P - 1) / 2, (DAT)1) == P - 1) return -1;
		DAT a;
		do a = rand(); // 随机方法可能寄
		while (pow(I2 = (mul(a, a) - n + P) % P, (P - 1) / 2, (DAT)1) == 1); 
		DAT x = pow(pii{a, 1}, (P + 1) / 2, {1, 0}).X;
		return min(x, P - x);
	}
	#undef X
	#undef Y
};
```

#### 立方根

求一个非负整数 $x$ 满足 $x^3\equiv n(mod\ p)$  无解返回-1

* 复杂度期望$O(log\ p)$  (暂时不会求最小解/全部解) 

* 接口 `int ans2 = Cube_root(n, p)();`

* 封装的`int` 版本  换 `long long` 见注释

```cpp
struct Cube_root{
    typedef int DAT;//操作数类型
    const DAT n,p;Cube_root(DAT _n=1,DAT _p=1):n(_n%_p),p(_p){};
    struct Z3{DAT x,y,z;};
    DAT mul(DAT a,DAT b)const{return (LL)a*b%p;}  //DAT=int
    //DAT mul(DAT a,DAT b)const{u64 r=(u64)a*b-(u64)((LD)a/p*b+0.5L)*p;return r<p?r:r+p;}  //DAT=long long
    Z3 mul(Z3 a,Z3 b)const{return(Z3){
        (mul(a.x,b.x)+mul((mul(a.y,b.z)+mul(a.z,b.y))%p,n))%p,
        ((mul(a.x,b.y)+mul(a.y,b.x))%p+mul(mul(a.z,b.z),n))%p,
        ((mul(a.x,b.z)+mul(a.y,b.y))%p+mul(a.z,b.x))%p
    };}
    template<class T>T pow(T a,DAT b,T x)	
    	{for(;b;b/=2,a=mul(a,a))if(b&1)x=mul(x,a);return x;}
    DAT operator()(){ 
        if(n==0||p<=3)return n;
        if(p%3==2)return pow(n,(2*p-1)/3,(DAT)1);
        if(pow(n,(p-1)/3,(DAT)1)!=1)return -1;
        Z3 r;
        do r=pow((Z3){rand(),rand(),rand()},(p-1)/3,(Z3){1,0,0});
        while(r.x!=0||r.y==0||r.z!=0); // 随机方法可能寄
        return pow(r.y,p-2,(DAT)1);
    }
};
```



## 线性筛

```cpp
int ntp[N],pri[N],tot;
inline void linear_sieve(int n){
    ntp[1]=1;for(int i=2;i<=n;++i)ntp[i]=0;tot=0;//初始化 一般可省
    for(int i=2;i<=n;++i){
        if(!ntp[i])pri[++tot]=i;
        for(int j=1;j<=tot;++j){
            const LL nex=(LL)i*pri[j];if(nex>n)break;//n<=1e6则不必开LL
            ntp[nex]=1;
            if(i%pri[j]==0)break;
        }
    }
}
```



## 欧拉函数$\phi(x)$
* 求$\phi(x)$的值可以归约为找$x$的质因子
* $O(\sqrt{x})$求点值
```cpp
template <typename T>
inline T phi(T x) {
	T res = x;
	for (T i = 2; i * i <= x; ++i)
		if ((x % i) == 0) {
			res = res / i * (i - 1);
			while ((x % i) == 0) x /= i;
		}
	if (x > 1) res = res / x * (x - 1);
	return res;
}
```
* 或者线性筛出$\phi (1..n)$



## 数论分块

对于给定的正整数 $n$ 和 $i$，使得
$$\lfloor \frac{n}{i}\rfloor =\lfloor \frac{n}{j}\rfloor $$
成立的最大正整数（满足$i<=j<=n$）的 $j$ 的值为 $\lfloor \frac{n}{\lfloor \frac{n}{i}\rfloor}\rfloor$

即 $\lfloor \frac{n}{i}\rfloor$ 所在块的右端点为 $\lfloor \frac{n}{\lfloor \frac{n}{i}\rfloor}\rfloor$



## 莫比乌斯反演

* 狄利克雷卷积 $*$ 的代数性质
  * 交换律、结合律
  * 对加法分配律 
  * 单位元 $\epsilon=[n==1]$ 
  * 对 $f(1)\neq0$ 的 $f$ 存在逆元 $g$   
  * 两个积性函数的狄利克雷卷积仍是积性函数
* $\mathbb 1*\mu=\epsilon$
* $\mathbb 1 *\phi=id$
* 设 $f$ 和 $g$ 是数论函数(N->R)，且当 $n>M$ 时有 $f(n)=g(n)=0$，则
  * $f(n)=\sum_{n|m}g(m)\iff g(n)=\sum_{n|m}\mu(\frac m n)f(m)$



## 杜教筛

~~在学了~~

给定函数 $f$ 和一个较大的 $n$，要计算其前缀和 $S(n)=\sum_{i=1}^nf(i)$，考虑构造一个函数 $g$ 与 $f$ 作卷积，有

 $\sum_{i=1}^n(f*g)(i)=\sum_{i=1}^n\sum_{xy=i}f(x)g(y)=\sum_{y=1}^ng(y)S(\lfloor\frac{n}{y}\rfloor)$ 

即 $g(1)S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{y=2}^ng(y)S(\lfloor\frac{n}{y}\rfloor)$ 

复杂度：

*  $(f*g)$ 的前缀和与 $g$ 的区间和都可以快速计算（一般是推出可O(1)计算的表达式，或者与 $S$ 同时用杜教筛计算）
*  $S(n)$ 可以线性复杂度预处理出前 $N^{\frac{2}{3}}$ 项，后面的项用记忆化搜索

总复杂度 $O(N^{\frac{2}{3}})$ 



洛谷某dalao某模板题代码Orz
```cpp
typedef long long LL;
const int maxn = 2147483647;
const int maxm = 2000000;

LL S1[maxm], S2[1300];
bool vis[1300];
int N;

LL S(int n) {
  if (n < maxm) return S1[n];
  int x = N / n; // 如果存在某个 x 使得 n = floor(N / x)，
                 // 选 x = floor(N / n) 一定可以。
  if (vis[x]) return S2[x];
  vis[x] = true;
  LL &ans = S2[x];
  ans = (LL)n * (n + 1) / 2; // 对 (f*g)(n) = n 求和
  for (int i = 2, j; i <= n; i = j + 1) {
    j = n / (n / i);
    ans -= (j - i + 1) * S(n / i);
  }
  return ans;
}
```



## Miller-Rabin素性测试
loj143  luoguP4718

* $n<=10^{18}$

* 需要 `快速乘` `64位快速幂`

* http://miller-rabin.appspot.com/

* 此实现仍有被hack可能  如果WA就换base:

* * 2^64以内保证正确的7个base: 2, 325, 9375, 28178, 450775, 9780504, 1795265022

```cpp
inline bool MR(LL a,const LL&d,const int&t,const LL&n){//注意a%n==0时应判定通过测试
    a%=n;if(a==0)return 1;
    a=fpl(a,d,n);
    if(a==1||a==(n-1))return 1;
    for(int i=1;i<t;++i){
        a=mul(a,a,n);
        if(a==(n-1))return 1;
        if(a==1)return 0;
    }
    return 0;
}

constexpr LL a[]={2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375};
inline bool isPrime(LL n){ 
    if(n==2||n==3)return 1;if(n<2||(n%2==0)||(n%3==0))return 0;//特判最好别省
    if(n==585226005592931977LL)return 0;//这6个基的最小反例 暂不清楚1e18内有无其它反例
    LL d=n-1;int t=0;while((d&1)==0)d>>=1,++t;
    for(int i=0;i<6;++i)if(!MR(a[i],d,t,n))return 0;
    return 1;
}
```



## Pollard-Rho 分解质因数

* 需要 `快速乘` `gcd`

* 返回 $n$ 的一个大于1的真因子 不存在就死循环 寄！

* 务必在调用前确认 $n$ 是合数 (>1)

```cpp
mt19937 mt(time(0)); //随机化
inline LL PR(LL n) {
    LL x = uniform_int_distribution<LL>(0, n - 1)(mt), s, t, c = uniform_int_distribution<LL>(1, n - 1)(mt); //随机化
    for (int gol = 1; 1; gol <<= 1, s = t, x = 1) {
        for (int stp = 1; stp <= gol; ++stp) {
            t = (mul(t, t, n) + c) % n;
            x = mul(x, abs(s - t), n);
            if ((stp & 127) == 0) {
                LL d = gcd(x, n);
                if (d > 1) return d;
            }
        }
        LL d = gcd(x, n);
        if (d > 1) return d;
    }
}
```



## 组合数

* 数较小 模数为较大质数  求逆元 

* * 如果模数固定可 O(n) 预处理阶乘逆元

* 数较大 模数为较小质数  用 $Lucas$ 定理

* * $$C_n^m\equiv C_{\lfloor \frac np\rfloor}^{\lfloor \frac mp\rfloor}*C_{n\ mod\ p}^{m\ mod\ p}(mod\  p)$$

* 数较大 模数较小但不保证为质数 用 $exLucas$ 算法求  $C_n^m mod\ P$

### exLucas

luoguP4720

* 前置算法 `快速乘` `快速幂` `crt合并同余方程`

* 单次询问O(P log P)  

* 不要求P为质数

```cpp
namespace EXLUCAS {
	inline LL g(LL n, LL p) {
		LL nn = n;
		while (n > 0) nn -= (n % p), n /= p;
		return nn / (p - 1);
	}

	LL f(LL n, LL p, LL pk) {
		if (n == 0) return 1;
		LL res = 1;
		if (n >= pk) {
			LL t = n / pk, k = 1, els = n - t * pk;
			for (LL i = 1; i <= els; ++i) if (i % p) k = k * i % pk;
			res = k;
			for (LL i = els + 1; i < pk; ++i) if (i % p) k = k * i % pk;
			res = res * fp(k, n / pk, pk) % pk;
		}
		else for (LL i = 1; i <= n; ++i) if (i % p) res = res * i % pk;
		return res * f(n / p, p, pk) % pk;
	}

	inline LL exlucas(LL n, LL m, LL p, LL pk, LL k) {
		LL a = f(n, p, pk) * fp(f(n - m, p, pk) * f(m, p, pk) % pk, pk / p * (p - 1) - 1, pk) % pk;
		LL b = g(n, p) - g(m, p) - g(n - m, p);
		if (b >= k) return 0;
		while (b--) a *= p;
		return a % pk;
	}

    /*接口*/ inline LL exlucas(LL n, LL m, LL p){
        pll r = {0, 1};
        for (LL i = 2; i * i <= p; ++i)if (p % i == 0){
            LL t = 0, pk = 1;
            while (p % i == 0)++t, p /= i, pk *= i;
            crt(r, {exlucas(n, m, i, pk, t), pk});
        }
        if (p > 1)crt(r, {exlucas(n, m, p, p, 1), p});
        return r.first;
    }
}
```



## 类欧几里得算法

### 洛谷模板题

* 计算直线下整点数

* `f=∑[(ai+b)/c]`  `g=∑i[(ai+b)/c]`  `h=∑[(ai+b)/c]^2`  `i=0..n  a,b,n∈N  c∈N*`

* 复杂度`log(MAX{a,c})`

```cpp
struct dat{LL f, g, h;};
const LL i2 = 499122177, i3 = 332748118, M = 998244353; //预处理出模M意义下2和3的逆元
dat f(LL a, LL b, LL c, LL n){
    LL ac = a / c, bc = b / c;
    LL n2 = (n * (n + 1) % M) * i2 % M, n3 = n2 * (2ll * n + 1) % M * i3 % M;
    dat res = {
        (n2 * ac % M + (n + 1) * bc % M) % M, 
        (ac * n3 % M + bc * n2 % M) % M, 
        (ac * ac % M * n3 % M + 
            bc * bc % M * (n + 1) % M + ac * bc % M * n2 % M * 2ll) % M};
    a %= c; b %= c; if (a == 0)return res;
    LL m = (a * n + b) / c;
    dat p = f(c, c - b - 1, a, m - 1);
    LL fc = (n * m % M - p.f + M) % M, gc = (n2 * m % M - i2 * (p.f + p.h) % M + M) % M;
    return{(res.f + fc) % M,    (res.g + gc) % M, 
    (res.h + 2ll * (bc * fc % M + ac * gc % M) % M + 
        n * m % M * m % M - 2ll * p.g - p.f + 3ll * M) % M};}
```

### LOJ模板题

~~在学了 QAQ~~



## 数值积分

* 自适应辛普森算法 

* 复杂度 O(玄学)

* luogu p4542

```cpp
struct IG{
    typedef double Func(double);
    const Func*f;IG(const Func&g):f(&g){}
    double simpson(double l,double r)const{
        double mid=(l+r)/2;
        return (r-l)*(f(l)+4*f(mid)+f(r))/6;
    }
    double find(double l,double r,const double&EPS,double res)const{
        double mid=(l+r)/2;
        double fl = simpson(l, mid), fr = simpson(mid, r);
        if (abs(fl + fr - res) <= 15 * EPS)return fl + fr + (fl + fr - res) / 15; 
        return find(l, mid, EPS / 2, fl) +find(mid, r, EPS / 2, fr);  
    }
    double operator()(double l,double r,double EPS=1e-8)const{return find(l,r,EPS,simpson(l,r));}
};

struct Integration{
    typedef double Func(double);
    const Func*f;Integration(const Func&g):f(&g){}
    typedef pair<double,double> pdd;
    pdd add(pdd a,pdd b)const{
        double mid=(a.first+b.first)/2;
        return (pdd){mid,f(mid)};
    }
    #define simpson(p1,p2,p3) (((p3).first-(p1).first)*((p1).second+4*(p2).second+(p3).second)/6)
    double find(pdd p1,pdd p3,pdd p5,double EPS,double res,int dep)const{
        pdd p2=add(p1,p3),p4=add(p3,p5);
        double fl=simpson(p1,p2,p3),fr=simpson(p3,p4,p5),d=(fl+fr-res)/15;
        if(abs(d)<=EPS&&dep<0)return fl+fr+d; 
        return find(p1,p2,p3,EPS/2,fl,dep-1)+find(p3,p4,p5,EPS/2,fr,dep-1);  
    }
    double operator()(double l,double r,double EPS=1e-6/*精度*/,int dep=12/*最小递归深度*/)const{
        pdd p1(l,f(l)),p3(r,f(r)),p2=add(p1,p3);
        return find(p1,p2,p3,EPS,simpson(p1,p2,p3),dep);
    }
    #undef simpson
};
```



## 日期操作

### 用于跳转的常量

```cpp
const LL year_1[2]={365, 366};
const LL year_400=1460097;
const LL m_day[13]={(LL)0x3f3f3f, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

### 辅助函数

```cpp
inline bool isLeap(LL t){return (t % 400 == 0) ||((t % 4 == 0) && (t % 100));}
inline bool pick(LL a, LL b){return ((isLeap(a) && b <= 2) ||(isLeap(a + 1) && b > 2));}
inline LL dayThisMonth(LL y, LL m){return m_day[m] + isLeap(y) * (m == 2);}
```

### 日期和整数的一一对应

* LL可以改成int

```cpp
struct MY_DATE{
    LL year, month, day;
    MY_DATE(LL y = 2021, LL m = 1, LL d = 1) : year(y), month(m), day(d){};
    LL p(MY_DATE op = {0, 0, 0}){//日期转换为整数
        LL y = year - op.year, m = month - op.month, d = day - op.day;
        if (m <= 2){ y--; m += 12;}
        return 365 * y + y / 4 - y / 100 + y / 400 + (153 * (m - 3) + 2) / 5 + d - 307;
    }
    MY_DATE run(LL k){//当前日期过k天
        k += p();
        LL x = k + 1789995, n = 4 * x / 146097, i, j, d;
        x -= (146097 * n + 3) / 4;
        i = (4000 * (x + 1)) / 1461001;
        x -= 1461 * i / 4 - 31;
        j = 80 * x / 2447;
        d = x - 2447 * j / 80;
        x = j / 11;
        return MY_DATE(100 * (n - 49) + i + x, j + 2 - 12 * x, d);
    }
};
```



## 环染色问题

* poj2154 Burnside引理

```cpp
#include<cstdio>
using namespace std;
typedef long long LL;
#define pln putchar('\n')
const int N=100009;

int n,p,ans;

LL fp(LL a,LL b,LL Mod){
    LL res=(Mod!=1);
    for(;b;b>>=1,a=a*a%Mod)if(b&1)res=res*a%Mod;
    return res;
}

int ntp[N],pri[N],tot;

int f[33],t[33],d;

void dfs(int x,int phi,int u){
    if(x>d){
        ans=(ans+phi*fp(n,n/u-1,p))%p;
        return;
    }
    dfs(x+1,phi,u);
    u*=f[x];
    phi*=(f[x]-1);
    dfs(x+1,phi,u);
    for(int i=2;i<=t[x];++i){
        u*=f[x];
        phi*=f[x];
        dfs(x+1,phi,u);
    }
}

void solve(int T){
    scanf("%d%d",&n,&p);d=0;
    int x=n;
    for(int i=1;i<=tot;++i){
        if(pri[i]*pri[i]>x)break;
        if(x%pri[i])continue;
        int k=0;while(x%pri[i]==0)x/=pri[i],++k;
        f[++d]=pri[i];
        t[d]=k;
    }
    if(x>1){
        f[++d]=x;
        t[d]=1;
    }
    ans=0;
    dfs(1,1,1);
    printf("%d\n",ans);
}

signed main(){
    for(int i=2;i<=40000;++i){
        if(!ntp[i])pri[++tot]=i;
        for(int j=1;j<=tot;++j){
            int nex=pri[j]*i;
            if(nex>40000)break;
            ntp[nex]=1;
            if(i%pri[j]==0)break;
        }
    }
    int t;scanf("%d",&t);
    for(int i=1;i<=t;++i)solve(i);
    return 0;
}
```



## 拉格朗日插值

构造一个过给定 $n$ 个点 $(x_1,y_1),(x_2,y_2),...,(x_n,y_n)$ 的多项式

$f(x)=\sum_{i=1}^{n}(y_i * \prod_{j\neq i}\frac{x-x_j}{x_i-x_j})$



## 曼哈顿距离与切比雪夫距离

设 $A(x_1,y_1)$，$B(x_2,y_2)$ 

曼哈顿距离 $d(A,B)=|x_1-x_2|+|y_1-y_2|=\max(|(x_1+y_1)-(x_2+y_2)|,|(x_1-y_1)-(x_2-y_2)|)$

这正是 $(x_1+y_1,x_1-y_1)$ 与 $(x_2+y_2,x_2-y_2)$ 的切比雪夫距离

因此将每个点 $(x,y)$ 转化为 $(x+y,x-y)$ ，原坐标系的曼哈顿距离就是新坐标系下的切比雪夫距离

同理，将每个点 $(x,y)$ 转化为 $(\frac{x+y}{2},\frac{x-y}{2})$，原坐标系的切比雪夫距离就是新坐标系下的曼哈顿距离



## 因子数 $d(n)$ 的数量级

* [A066150 Maximal number of divisors of any n-digit number](http://oeis.org/A066150)

4, 12, 32, 64, 128, 240, 448, 768, 1344, 2304, 4032, 6720, 10752, 17280, 26880, 41472, 64512, 103680, 161280, 245760, 368640, 552960, 860160, 1290240, 1966080, 2764800, 4128768, 6193152, 8957952, 13271040, 19660800, 28311552, 41287680, 59719680, 88473600, 127401984, 181665792, 264241152, 382205952, 530841600



## 置换群

* 可旋转涂色问题

给一个 $n$ 元环涂色，$m$ 种颜色，旋转后得到的方案算同一种，求不同的方案数

$\frac{1}{n}\sum^{n-1}_{i=0}m^{gcd(n,i)}=\frac{1}{n}\sum_{d|n}\phi(d)m^{n/d}$

### 轮换指标

设 $x_i$ 表示置换中的 $i$ 元环

* 正 $n$ 边形的旋转群

$\frac{1}{n}\sum_{d|n}\phi(d)x_d^{n/d}$

* 正 $n$ 边形的二面体群

$$
\frac{1}{2n}\sum_{d|n}\phi(d)x_d^{n/d}+ \begin{cases}\frac{1}{2}x_1x_2^{\frac{n-1}{2}}\qquad & {n\ is\ odd} \\ \frac{1}{4}(x_2^{\frac{n}{2}}+x_1x_2^{\frac{n-2}{2}})\qquad & {n\ is\ even} \end{cases}
$$

* 正方体的顶点置换群

$\frac{1}{24}(x_1^8+8x_1^2x_3^2+9x_2^4+6x_4^2)$

* 正方体的边置换群

$\frac{1}{24}(x_1^{12}+8x_3^4+6x_1^2x_2^5+3x_2^6+6x_4^3)$

* 正方体的面置换群

$\frac{1}{24}(x_1^6+8x_3^2+6x_2^3+3x_1^2x_2^2+6x_1^2x_4)$



## 多项式快速幂

给定 $F(x)(mod\ x^n)$ ，求 $F^k(x)(mod\ x^n)$

$k,n$ 不大，系数集不成域，$O(n \log n\log k)$ 分治NTT

$k$ 很大，且系数模奇质数 $p$ ($p>n$)：

$F[0]=1$，根据 $f(x^p)\equiv f^p(x)(mod\ p)$ ，则 $F^p(x)\equiv F[0]=1(mod\ x^p)=1(mod x^n)$，直接令 $k\%=p$ 后计算 $\exp(k\ln F(x))$

$F[0]!=1$ ，提出最低次非 $0$ 系数 $ux^t$ 后化为上一种情形 $F^k(x)=u^kx^{tk}G^k(x)$，其中 $G[0]=1$，注意 $u$ 的幂模 $p-1$ ，$G$ 的幂模 $p$



## 广义二项式系数

$C(n,m)=\frac{n^{m\over}}{m!}$，$n$ 是实数

$(1-x)^{-(d+1)}=\sum_{n\geq 0}C(d+n,n)x^n$，$d$ 是实数



## Fibonacci数列

$F_1=1,F_2=1,F_{n+2}=F_{n+1}+F_n$ 

$F_n=\frac{\sqrt 5}{5}((\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n)$



## Catalan数

$H_0=1,H_1=1$

$H_n=\sum_{i=0}^{n-1}H_iH_{n-i-1}$  $n\geq 2$

$H(x)=\sum_{n\geq 0}\frac{C(2n,n)}{n+1}x^n$



## 错排数

容斥原理   $n! \sum_ {k=0}^n\frac{(−1)^k}{k!}$



## 盒子放球方案数

luoguP5824 记得检查 n<=m 之类的合法性条件

给定正整数 $n,m$，问 $n$ 个球全部放入 $m$ 个盒子的方案数，不同的限制条件如下



#### 划分数(与第二类Stirling数相关)

* 球之间互不相同，盒子之间互不相同。
* * $m^n$
* 球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。
* * $m^{n\over}$
* 球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。
* * $m!S_2(n,m)$



* 球之间互不相同，盒子全部相同。
* * $\sum_{i=1}^m S_2(n,i)$
* 球之间互不相同，盒子全部相同，每个盒子至多装一个球。
* * $[n\leq m]$
* 球之间互不相同，盒子全部相同，每个盒子至少装一个球。
* * $S_2(n,m)$



#### 一类不定方程解数
* 球全部相同，盒子之间互不相同。
* * $C(n+m-1,m-1)$
* 球全部相同，盒子之间互不相同，每个盒子至多装一个球。
* * $C(m,n)$
* 球全部相同，盒子之间互不相同，每个盒子至少装一个球。
* * $C(n-1,m-1)$



####  盒子有限的整数分拆
* 球全部相同，盒子全部相同。
* * $[x^n](\prod_{i=1}^m{\frac{1}{1-x^i}})$
* 球全部相同，盒子全部相同，每个盒子至多装一个球。
* * $[n\leq m]$
* （整数的m分拆）球全部相同，盒子全部相同，每个盒子至少装一个球。
* * OGF： $n<m\ ?\ 0\ :\  [x^{n-m}](\prod_{i=1}^m{\frac{1}{1-x^i}})$
  * 记答案为 $p(n,m)$ ，递推式 $p(n,m) = p(n-1,m-1)+p(n-m,m)$  



## 第二类Stirling数

$n$ 个带标号球全部放入 $m$ 个无标号盒子，且所有盒子非空的方案数

* $S_2(n,0)=[n=0]$
* $S_2(n,m)=S_2(n-1,m-1)+mS_2(n-1,m)$
* $S_2(n,m)=\sum_{i=0}^{m}\frac{(-1)^i\ (m-i)^n}{i!\ (m-i)!}$  可以卷积算一行
* 考虑 $n$ 个带标号球全部放入 $m$ 个带标号盒子共有 $m^n$  种方案，有和式 $m^n=\sum_{k=0}^mS_2(n,k)m^{k\over}$
* 列EGF $\sum_{n\geq 0}S_2(n,m)\frac{x^n}{n!}=\frac{1}{m!}(e^x-1)^m$



## 分拆数

$n$ 个无标号球全部放入一些(个数无限制)无标号盒子，要求每个盒子非空 

记方案数为 $P(n)$ 

* $P(n)=\sum_{m=1}^n p(n,m)$
* OGF：$\sum_{n\geq 0}P(n)x^n=\prod_{n\geq 1}\frac{1}{1-x^n}$

### 五边形数定理

广义五边形数 $g_n=\frac{1}{2}n(3n-1)$

对于 $n=0,1,-1,2,-2,3,-3,...$

$g_n$ 的前几项为 $0,1,2,5,7,12,15,22,26,...$

欧拉函数的OGF 

$$
\phi(x)=\prod_{i=1}^{\inf}(1-x^i)
=1-x-x^2+x^5+x^7-x^{12}-x^{15}
\\
=1+\sum_{i=1}^{\inf}(-1)^i(x^{i(3i-1)/2}+x^{-i(-3i-1)/2})
$$

其中 $i(3i-1)/2$ 与 $-i(-3i-1)/2$ 恰好是相邻的广义五边形数

由 $P(x)\phi(x)=1$ 得

$P(1)=1$

$P(n)=P(n-1)+P(n-2)-P(n-5)-P(n-7)+...$ 



有时可以用来 $O(n\sqrt n)$ 预处理分拆数，比约 $O(50nlogn)$ 的龟速MTT省事(HDU6042)



## 第一类Stirling数

求有 $k$ 个轮换的 $n$ 元置换的方案数，记为 $S_1(n,k)$ 

* $S_1(n,0)=[n=0]$
* $S_1(n,k)=S_1(n-1,k-1)+(n-1)S_1(n-1,k)$
* 行OGF $x^{\over n}=\sum_{k=0}^nS_1(n,k)x^k$ 
* 列EGF $\sum_{n\geq 0}S_1(n,k)\frac{x^n}{n!}=\frac{1}{k!}ln^k(1+x)$



## Stirling反演(未验证)

$\sum_{k\geq 0}S_2(n,k)S_1(k,m)=[n=m]$

$f_n=\sum_{i=0}^nS_2(n,i)g_i\iff g_n=\sum_{i=0}^nS_1(n,i)f^i$ 
